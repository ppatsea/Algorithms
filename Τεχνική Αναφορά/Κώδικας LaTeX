\documentclass[paper=a4, fontsize=11pt]{scrartcl}
%\usepackage{fourier}
\usepackage[table,xcdraw]{xcolor}
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{graphicx}	
\usepackage{url}
\usepackage{bookmark}

\usepackage[Greek,Latin]{ucharclasses}
\usepackage{polyglossia}
\setdefaultlanguage{greek}
\setotherlanguages{english}
%%% Bibliography 
\usepackage{biblatex}
\addbibresource{ref.bib}


\usepackage{float}
\restylefloat{table}
%%%% algorithms
\usepackage{algorithm} 
\usepackage{algpseudocode} 
\usepackage{enumitem}

\graphicspath{ {./images/} }


%%%fonts
\usepackage{fontspec}
\setmainfont{FreeSerif}
\setsansfont{FreeSans}
\setmonofont{FreeMono}


\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}


\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#

%%%paragraph 
\setlength{\parindent}{1em}
\setlength{\parskip}{0.5em}

\usepackage{titlesec, lipsum}
\titleformat{\paragraph}[block]{\filcenter}{}{0pt}{}

%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule


\usepackage[colorlinks]{hyperref}



\title{
     \usefont{OT1}{bch}{b}{n}
     \normalfont \normalsize \textsc{Πανεπιστήμιο Ιωαννίνων Τμήμα Πληροφορικής \& Τηλεπικοινωνίων} \\ [1em]
     \normalfont \normalsize \textsc{Πρόγραμμα Μεταπτυχιακών Σπουδών “Πληροφορικής \& Δικτύων”} \\ [1em]
     \normalfont \normalsize \textsc{Αλγόριθμοι \& Προχωρημένες Δομές Δεδομένων} \\ [1em]
     \horrule{0.5pt} \\[0.4cm]
     \huge Πρόβλημα PFSP \\
     \horrule{2pt} \\[0.5cm]


     \begin{figure}[h]
    \centering
    \includegraphics[scale=0.65]{εξώφυλλο.png}
    \label{fig:εξώφυλλο}
\end{figure}
}

\author{
    \normalfont
         Περσεφόνη Πατσέα  
         \\Α.Μ.: 185
         \\1ο Εξάμηνο\\[-1pt]
         \today
}

\date{}

\begin{document}

\maketitle

\newpage
\tableofcontents
\newpage

\section*{Περίληψη}
   Η αντιμετώπιση του Permutation Flow-Shop Scheduling Problem (PFSP), αφορά τον προγραμματισμό χρόνου εκτέλεσης ενός συνόλου εργασιών σε ένα σύνολο μηχανών ούτως ώστε να επιτευχθεί ο συντομότερος χρόνος ολοκλήρωσης για την εργασία που ολοκληρώνει την επεξεργασία της τελευταία. Σ’ αυτή την τεχνική αναφορά, εξετάζεται η υλοποίηση αλγορίθμων και υποστηρικτικών δομών δεδομένων για την αποδοτική επίλυση του προβλήματος καθώς και η εμπειρική εκτίμηση της απόδοσης της προσέγγισης μέσω της επίλυσης δημόσια δημοσιευμένων στιγμιότυπων προβλημάτων.

\vspace{1cm}

\section{Εισαγωγή}
    Το πρόβλημα PFSP μπορεί να περιγραφεί απλά ως εξής: 
    
    Υπάρχουν n εργασίες (jobs) και m μηχανήματα (machines). Κάθε εργασία πρέπει να περάσει από όλες τις μηχανές με την ίδια σειρά (από την πρώτη μέχρι την τελευταία μηχανή) και επιπλέον κάθε μηχανή πρέπει να επεξεργάζεται την ίδια διάταξη (permutation) εργασιών με όλες τις άλλες μηχανές. Ο περιορισμός αυτός μπορεί να επιβάλλεται αν κάθε εργασία παράγει σταδιακά ένα προϊόν σε μια γραμμή παραγωγής με ιμάντα, που δεν επιτρέπει σε μια εργασία να πάρει τη σειρά μιας άλλης εργασίας σε κάποιο από τα μηχανήματα. Ο χρόνος επεξεργασίας κάθε εργασίας, σε κάθε μηχανή δίνεται, και έτσι ζητείται να βρεθεί η διάταξη των εργασιών που ελαχιστοποιεί το λεγόμενο makespan, δηλαδή το χρόνο ολοκλήρωσης της εργασίας που ολοκληρώνει την επεξεργασία της τελευταία.

    
\vspace{1cm}

    
\section{Αποτελέσματα}
    Για την συγγραφή των πειραμάτων χρησιμοποιήθηκε η Python 3.10.0 και το Visual Studio Code. Τα χαρακτηριστικά του υπολογιστή είναι i5 7600 (3.50 GHz), 16.0 GB RAM. Για την οπτικοποίηση των αποτελεσμάτων χρησιμοποιήθηκε η βιβλιοθήκη matplotlib, η seaborn και η tkinter.

\vspace{0.5cm}

\textbf{Οδηγίες Εκτέλεσης του Κώδικα:} 
\\Για να εκτελέσουμε τον κώδικα, κάνουμε τα εξής βήματα: 
\begin{enumerate}[label=\roman*)]
\item	Εκκινούμε το Visual Studio Code
\item	Ανοίγουμε το φάκελο που είναι αποθηκευμένοι οι κώδικες \textbf{(File → Open Folder)}
\item	Διαλέγουμε τον κώδικα που επιθυμούμε να τρέξουμε
\item	Πατάμε από το πληκτρολόγιο τα εξής κουμπιά \textbf{(CTRL + SHIFT + C)} προκειμένου να ανοίξει το Command Window
\item	Όταν ανοίξει εισάγουμε την εντολή:

\begin{center}
 \textbf{python file\_name.py}
\end{center}

Όπου \textbf{file\_name}, το όνομα του εκάστοτε κώδικα που θέλουμε να εκτελέσουμε
\end{enumerate}

\vspace{0.5cm}

Ειδικότερα, για τους κώδικες που έχουν δημιουργηθεί, οι εντολές εκτέλεσης είναι οι εξής:
\begin{enumerate}[label=\roman*)]
\item	Για τον κώδικα: \textbf{pfsp.py		→	python pfsp.py}
\item	Για τον κώδικα: \textbf{window.py	→	python window.py}
\item	Για τον κώδικα: \textbf{NEH.py		→	python NEH.py}
\item	Για τον κώδικα: \textbf{On2m.py	→	python On2m.py}
\item	Για τον κώδικα: \textbf{tabu.py		→	python tabu.py}
\end{enumerate}


\vspace{1cm}

\section{Απαντήσεις Ερωτημάτων Εργασίας}
\subsection{Ορίστε το πρόβλημα τυπικά (αυστηρά), συμπεριλαμβανομένων όλων των παραμέτρων. Σχολιάστε τη σημασία του προβλήματος σε πραγματικές εφαρμογές.}


Το πρόβλημα αλληλουχίας της κατάστασης ροής, συγκροτεί ένα πρόβλημα, όσον αφορά τον προγραμματισμό μίας παραγωγής, η οποία αποτελείται από n (jobs) και m (machines). Πιο συγκεκριμένα, τα jobs, ειδάλλως αντικείμενα, εργασίες, κ.ο.κ., οφείλουν να διεκπεραιωθούν με την ίδια σειρά σε machines. Ο τύπος που ορίζεται για το χρόνο επεξεργασίας της εργασίας i στη μηχανή  j, είναι ο κάτωθι:

\begin{center}
$t_{i j}(i=1, \ldots, n ; j=1, \ldots, m)$
\end{center}

Οι χρόνοι αυτοί είναι μη αρνητικοί, σταθεροί και ορίζονται από τους χρόνους οι οποίοι ενδεχομένως να είναι μηδενικοί, εφόσον κάποια εργασία δε δέχεται επεξεργασία από μία μηχανή.

\vspace{0.5cm}

Το πρόβλημα συνίσταται στην ελαχιστοποίηση του χρόνου, τη λεγόμενη  ακολουθία (makespan). Δηλαδή έγκειται μεταξύ της έναρξης της εκτέλεσης της πρώτης εργασίας στην πρώτη μηχανή, και της ολοκλήρωσης της εκτέλεσης της τελευταίας εργασίας στην τελευταία μηχανή. 
Για το εν λόγω πρόβλημα συνίστανται οι παρακάτω παραδοχές:

\begin{itemize}
\item {Κάθε εργασία διεκπεραιώνεται το πολύ μία φορά στις μηχανές 1, 2 , ..... , m (με αυτήν ακριβώς τη σειρά). }

\item {Ο αριθμός των εργασιών που δέχεται επεξεργασία από κάθε μηχανή, κάθε φορά, είναι μόνο μία.}

\item {Κάθε φορά, κάθε εργασία, υπόκειται σε επεξεργασία, το πολύ σε ένα μηχάνημα.}

\item {Οι εργασίες δε δύναται να διακοπούν.}

\item {Οι χρόνοι προετοιμασίας των εργασιών περιλαμβάνονται στο χρόνο επεξεργασίας και δεν εξαρτώνται από την ακολουθία.}

\item {Οι ακολουθίες λειτουργίας των εργασιών είναι οι εξής: ίδιες σε κάθε μηχάνημα και οι κοινές οφείλουν να προσδιορίζονται.}
\end{itemize}

\vspace{0.5cm}

Συνοψίζοντας, το εν λόγω πρόβλημα είναι NP-hard, ειδάλλως μη ντετερμινιστική πολυωνυμική σκληρότητα χρόνου, και μπορεί να επιλυθεί  μόνο για μικρά μεγέθη. Τέλος, αποτελείται από την εύρεση μιας ακολουθίας που ελαχιστοποιεί το makespan, το λεγόμενο M(σ). Επομένως, ο αριθμός των πιθανών χρονοδιαγραμμάτων είναι n!, τουτέστιν 1 x 2 x … x n.

\vspace{0.5cm}

Η σημασία του προβλήματος σε πραγματικές εφαρμογές, έχει την κάτωθι σημασία:

Δίνονται 5 jobs: \textbf{A, B, C, D, E}
\begin{enumerate}
\item {Ταξινόμηση της λίστας των job
\\Ταξινομημένη Λίστα: A, E, B, C, D}

\item {Επιλογή των A \& E, με πιθανές ακολουθίες τις Α → Ε ή Ε → Α. 
\\Εντοπίζεται η καλύτερη ακολουθία, ανάμεσα σ’ αυτές τις δύο. 
\\Αν η καλύτερη είναι η \textbf{Ε → Α}, δεν αλλάζει θέση ξανά.}

\item {Επιλογή του Β και εισαγωγή του στις 3 πιθανές θέσεις: 
\\Β → Ε → Α , 
\\Ε → Β → Α , 
\\E → A → B. 
\\Εντοπίζεται η καλύτερη: \textbf{Β → Ε → Α}}

\item {Επιλογή του C και εισαγωγή του στις 4 πιθανές θέσεις: 
\\C → Β → Ε → Α , 
\\B → C → E → A , 
\\B → E → C → A , 
\\B → E → A → C. 
\\Εντοπίζεται η καλύτερη: \textbf{Β → Ε → Α → C}}

\item {Επιλογή του D και εισαγωγή του στις 5 πιθανές θέσεις: 
\\D → B → E → A → C , 
\\B → D → E → A → C , 
\\B → E → D → A → C , 
\\B → E → A → D → C , 
\\B → E → A → C → D. 
\\Εντοπίζεται η καλύτερη: \textbf{D → Β → Ε → Α → C}}
\end{enumerate}

\vspace{0.5cm}

Στην καθημερινή ζωή, η υλοποίηση του Αλγορίθμου NEH, χρησιμοποιείται στην επεξεργασία τροφίμων, στις χημικές παραγωγές, και στις βιομηχανίες γενικότερα, εξαιτίας της πολύ καλής λύσης που παρέχει, χωρίς όμως να είναι βέλτιστη. 
Ο μαθηματικός τύπος που εκφράζει το συγκεκριμένο αλγόριθμο, είναι:

\begin{center}
\textbf{$N E H \rightarrow \frac{n(n+1)}{2}$ sequences}
\end{center}

\vspace{0.5cm}

Αφού:
\begin{itemize}
\item {$1 \times 2 \times 3 \times 4 \times \ldots \times n=n !$}

\item {$1+2+3+4+\ldots+\mathrm{n}=\frac{n(n+1)}{2}$}
\end{itemize}


\vspace{1cm}

\subsection{Διαβάστε τα στιγμιότυπα προβλημάτων από το [1]. }

Για την υλοποίηση του συγκεκριμένου υπό-ερωτήματος, υλοποιήθηκαν οι κώδικες \textbf{pfsp.py} και \textbf{window.py}.  

Στον κώδικα \textbf{pfsp.py}, υλοποιείται ένας απλός αλγόριθμος εύρεσης λύσης, ο οποίος δημιουργεί μία τυχαία διάταξη εργασιών. Ο συγκεκριμένος απλοϊκός επιλυτής, δέχεται δύο παραμέτρους: τον αριθμό των εργασιών και έναν προαιρετικό για την αρχικοποίηση με τυχαίους αριθμούς. Έτσι δημιουργείται μία τυχαία σειρά αριθμών που έχει εύρος τιμών από το 0 έως τον (αριθμό\_εργασιών – 1), και κατόπιν αυτή η σειρά αριθμών αντιστοιχίζεται σε μία πιθανή λύση για το εν λόγω πρόβλημα.

Στον κώδικα \textbf{window.py}, δημιουργείται ένα παράθυρο, όπου κατά την εκτέλεσή του, ο χρήστης επιθυμεί ποιο αρχείο dat επιθυμεί να διαβάσει, ούτως ώστε να οπτικοποιηθούν σε ένα γράφημα τα jobs και τα machines, αντίστοιχα. 

\vspace{1cm}

\subsection{Υλοποιήστε τον ευρετικό αλγόριθμο NEH (Nawaz, Enscore, Ham) [3] για την επίλυση του προβλήματος.}

Το 1982, προτάθηκε από τους Nawaz, Enscore και Ham, η έννοια του ευρετικού αλγορίθμου δημιουργίας λύσης, για το λεγόμενο PFSP πρόβλημα, ειδάλλως το flow-shop πρόβλημα. Ο συγκεκριμένος αλγόριθμος βρίσκεται στη βιβλιογραφία και ως NEH, ονομασία που προκύπτει από τα αρχικά ονόματα των δημιουργών του.

\vspace{0.5cm}

Τα βήματα του εν λόγω αλγορίθμου, είναι τα εξής:
\begin{enumerate}[label=\roman*)]
\item 	\textbf{1ο Βήμα:} Για κάθε εργασία i, υπολογίζεται ο συνολικός χρόνος επεξεργασίας που απαιτείται απ’ όλες τις μηχανές m, τουτέστιν:

\begin{center}
\textbf{$T_i=\sum_{j=1}^m t_{i j}$}
\end{center}

με $t_{i j}$ να αντιστοιχίζεται στο χρόνο που η εργασία i στη μηχανή j.

\item 	 \textbf{2ο Βήμα:} Οι εργασίες ταξινομούνται με φθίνουσα σειρά βάσει του $T_i$.

\item 	 \textbf{3ο Βήμα:} Από το \textbf{2ο Βήμα}, αντλούνται οι δύο πρώτες εργασίες της λίστας, και κατόπιν εντοπίζεται η διάταξη των δύο συγκεκριμένων εργασιών, οι οποίες δίνουν το μικρότερο makespan. Κατόπιν του αλγορίθμου, δεν αλλάζει η σχετική θέση των δύο συγκεκριμένων εργασιών. Έτσι, θέτεται το \textbf{i=3}. 

\item 		\textbf{4ο Βήμα:} Επιλέγεται από τη λίστα του \textbf{2ου Βήματος}, η εργασία που τοποθετείται στη θέση i, και έτσι βρίσκεται η θέση της στην προηγούμενη διάταξη, μέσω των i δυνατών θέσεων, οι οποίες δίνουν το μικρότερο makespan για το σύνολο εργασιών i. Αξίζει να σημειωθεί πως δεν αλλάζει η σχετική θέση των εργασιών που έχουν απομείνει.

\item 		\textbf{5ο Βήμα:} Αν το \textbf{i=n}, τότε ο αλγόριθμος τερματίζει. Ειδάλλως, θέτεται \textbf{i=i+1}, και πραγματοποιείται ανακατεύθυνση στο \textbf{4ο Βήμα}. 
\end{enumerate}

\vspace{0.5cm}

Τα παραπάνω βήματα του αλγορίθμου NEH, έχουν υλοποιηθεί στον κώδικα \textbf{NEH.py}. Ο συγκεκριμένος κώδικας υλοποιεί το δεδομένο ευρετικό αλγόριθμο για τη δημιουργία λύσης του προβλήματος Permutation Flow-Shop Scheduling Problem (PFSP). 

Τα δεδομένα των αρχείων βρίσκονται σε μορφή .dat, και αντλούνται online από έναν public φάκελο στο GitHub, που βρίσκεται στον κάτωθι σύνδεσμο:

\begin{center}
\textbf{\url{https://github.com/ppatsea/Algorithms}}
\end{center}

\vspace{0.5cm}

Επιπροσθέτως, κατά την εκτέλεση του κώδικα, εμφανίζονται στο Command Window \textbf{*}, τα εξής:
\begin{enumerate}[label=\roman*)]
\item	Βέλτιστη Διάταξη Εργασιών του αλγορίθμου NEH,

\item	Βέλτιστη Σειρά Εργασιών του αλγορίθμου NEH,

\item	Χρόνος Εκτέλεσης του αλγορίθμου NEH,

\item	Συνολικός Χρόνος Εκτέλεσης του κάθε αρχείου dat. 
\end{enumerate}


Μετά το πέρας εκτέλεσης των αρχείων, εμφανίζεται το τελικό Διάγραμμα Gannt των συγκεκριμένων αρχείων, και τέλος όταν ο χρήστης κλείσει το παράθυρο του γραφήματος, στο Command Window εμφανίζεται ο Συνολικός Χρόνος Εκτέλεσης όλου του Προγράμματος.

\vspace{1cm}

\textbf{*} : Ο χρήστης από τις κατάλληλες γραμμές κώδικα επιλέγει αν επιθυμεί τα αποτελέσματα να εμφανίζονται αποκλειστικά και μόνο στην οθόνη, ή εκτός από αυτό, να εγγράφονται αυτόματα και όχι χειροκίνητα, σε ένα αντίστοιχο txt αρχείο με την ονομασία \textbf{results\_NEH.txt}.


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{1.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου NEH, για τις εργασίες 1-20}
    \label{fig:1}
\end{figure}  


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{2.png}
    \caption{Command Window, αλγορίθμου NEH, για τις εργασίες 1-20}
    \label{fig:2}
\end{figure}  



\vspace{1cm}

\subsection{Υλοποιήστε την απεικόνιση λύσεων προγραμμάτων ως γραφήματα με το χρόνο στον άξονα x, τις μηχανές στον άξονα y και τις εργασίες ως επιμέρους κουτάκια στις κατάλληλες θέσεις.}


Η υλοποίηση απεικόνισης των λύσεων προγραμμάτων ως γραφήματα Gannt, με το χρόνο στον άξονα x, τις μηχανές στον άξονα y και τις εργασίες ως επιμέρους κουτάκια στις κατάλληλες θέσεις, επιτεύχθηκε με τη χρήση της βιβλιοθήκης της Python, τη \textbf{Matplotlib}. Όσον αφορά τη Matplotlib, πρόκειται για μία ολοκληρωμένη βιβλιοθήκη, που σχετίζεται με τη δημιουργία στατιστικών, κινούμενων και διαδραστικών απεικονίσεων στην Python. 

Επιπροσθέτως, η Matplotlib, παράγει στοιχεία που σχετίζονται με την ποιότητα δημοσίευσης σε μία ποικιλία μορφών έντυπης εκτύπωσης και διαδραστικών περιβαλλόντων όλων των πλατφορμών.
Προκειμένου κάποιος να εγκαταστήσει τη συγκεκριμένη βιβλιοθήκη, αρκεί να ανοίξει το command line των windows \textbf{(Κουμπί Windows + R → cmd)} και να πληκτρολογήσει την εξής εντολή:

\begin{center}
\textbf{pip install matplotlib}
\end{center}

\vspace{0.5cm}

Επίσης, η παραπάνω απεικόνιση επιτεύχθηκε με δεύτερο τρόπο, με τη χρήση της βιβλιοθήκης \textbf{Seaborn}. Αναλυτικότερα, η Seaborn είναι μια βιβλιοθήκη της Python, ώστε να οπτικοποιεί δεδομένα βασιζόμενη στη Matplotlib. Παρέχει μια διεπαφή υψηλού επιπέδου για τη σχεδίαση ελκυστικών και ενημερωτικών στατιστικών γραφικών.

Προκειμένου κάποιος να εγκαταστήσει τη συγκεκριμένη βιβλιοθήκη, αρκεί να ανοίξει το command line των windows \textbf{(Κουμπί Windows + R → cmd)} και να πληκτρολογήσει την εξής εντολή:

\begin{center}
\textbf{pip install seaborn}
\end{center}

Αξίζει να σημειωθεί πως είναι η πιο πρόσφατη σταθερή έκδοση. Είναι επίσης δυνατό να συμπεριληφθούν προαιρετικές στατιστικές εξαρτήσεις:

\begin{center}
\textbf{pip install seaborn[stats]}
\end{center}

\vspace{0.5cm}

Επιπλέον, για τον κώδικα \textbf{window.py}, χρησιμοποιήθηκε η βιβλιοθήκη \textbf{Tkinter}, προκειμένου κατά την εκτέλεση του, να εμφανίζεται στο χρήστη ένα παράθυρο, όπου κάθε φορά που εκτελείται ο κώδικας, θα ερωτάται, ποιο γράφημα επιθυμεί να αναπαρίσταται, από τα 120 διαθέσιμα txt αρχεία που δόθηκαν. Το πακέτο tkinter συνιστά την τυπική διεπαφή της Python 3 για την εργαλειοθήκη Tcl/Tk GUI (Graphical User Interface), και σα βιβλιοθήκη είναι πλήρως παραμετροποιήσιμη, επεκτάσιμη και εύχρηστη.

Τέλος, για την υλοποίηση του κώδικα window.py, πραγματοποιήθηκε μετατροπή των 120 αρχείων txt, σε αρχεία dat, και κατόπιν δημιουργήθηκε ένας public φάκελος στο GitHub που περιέχει αυτά τα 120 dat αρχεία, ώστε να διαβάζονται online τα δεδομένα.

Προκειμένου κάποιος να εγκαταστήσει τη συγκεκριμένη βιβλιοθήκη, αρκεί να ανοίξει το command line των windows \textbf{(Κουμπί Windows + R → cmd)} και να πληκτρολογήσει την εξής εντολή:

\begin{center}
\textbf{pip install tkintertable}
\end{center}



\subsection{Ο αλγόριθμος NEH έχει πολυπλοκότητα $O\left(n^3 m\right)$, αλλά με τις βελτιώσεις που προτείνονται στο [2] η πολυπλοκότητα του μπορεί να μειωθεί σε $O\left(n^2 m\right)$. Υλοποιήστε το βελτιωμένο αλγόριθμο και πραγματοποιήστε ανάλυση χρόνων εκτέλεσης που να δείχνει την υπεροχή του βελτιωμένου NEH αλγορίθμου.}


Τα βήματα που ακολουθεί ο αλγόριθμος NEH, είναι τα κάτωθι:
\begin{enumerate}[label=\roman*)]
\item	\textbf{1ο Βήμα:} Ταξινομεί τις n θέσεις εργασίας κατά φθίνουσα σειρά αθροισμάτων, των χρόνων επεξεργασίας, στις μηχανές.

\item	\textbf{2ο Βήμα:} Παίρνει τις δύο πρώτες εργασίες και τις προγραμματίζει, προκειμένου να ελαχιστοποιηθεί το μερικό makespan, εφόσον υπάρχουν μόνο δύο από αυτές τις εργασίες.

\item \textbf{3ο Βήμα:} Για k=3, το n:

\item	\textbf{4ο Βήμα:} Εισάγει την k-οστή εργασία στη θέση, μεταξύ των k πιθανών εργασιών, η οποία ελαχιστοποιεί το μερικό makespan.
\end{enumerate}

\vspace{0.5cm}

Η πολυπλοκότητα του βήματος (i) είναι \textbf{O(n log(n))}, από εκείνη του βήματος (ii) που είναι \textbf{O(m)}. Τέλος, το βήμα (iv) του αλγορίθμου NEH έχει πολυπλοκότητα \textbf{O(km)}. Οπότε συμπεραίνεται ότι οι αλγόριθμοι NEH εκτελούνται σε χρόνο \textbf{$O\left(n^2 m\right)$}.

\vspace{1cm}

Τα παραπάνω βήματα του βελτιωμένου αλγορίθμου NEH, έχουν υλοποιηθεί στον κώδικα \textbf{$O\left(n^2 m\right)$}. Ο συγκεκριμένος κώδικας υλοποιεί το δεδομένο ευρετικό αλγόριθμο για τη δημιουργία βέλτιστης λύσης του προβλήματος Permutation Flow-Shop Scheduling Problem (PFSP). Στην ουσία απαρτίζει τη βελτιωμένη εκδοχή του αλγορίθμου NEH.

Τα δεδομένα των αρχείων βρίσκονται σε μορφή .dat, και αντλούνται online από έναν public φάκελο στο GitHub, που βρίσκεται στον κάτωθι σύνδεσμο:

\begin{center}
\textbf{\url{https://github.com/ppatsea/Algorithms}}
\end{center}

Επιπροσθέτως, κατά την εκτέλεση του κώδικα, εμφανίζονται στο Command Window \textbf{*}, τα εξής:
\begin{enumerate}[label=\roman*)]
\item	Βέλτιστη Διάταξη Εργασιών του αλγορίθμου NEH,
\item	Βέλτιστη Σειρά Εργασιών του αλγορίθμου NEH,
\item	Χρόνος Εκτέλεσης του αλγορίθμου NEH,
\item	Συνολικός Χρόνος Εκτέλεσης του κάθε αρχείου dat. 
\end{enumerate}

Μετά το πέρας εκτέλεσης των αρχείων, εμφανίζεται το τελικό Διάγραμμα Gannt των συγκεκριμένων αρχείων, και τέλος όταν ο χρήστης κλείσει το παράθυρο του γραφήματος, στο Command Window εμφανίζεται ο Συνολικός Χρόνος Εκτέλεσης όλου του Προγράμματος.

\vspace{1cm}

\textbf{*} : Ο χρήστης από τις κατάλληλες γραμμές κώδικα επιλέγει αν επιθυμεί τα αποτελέσματα να εμφανίζονται αποκλειστικά και μόνο στην οθόνη, ή εκτός από αυτό, να εγγράφονται αυτόματα και όχι χειροκίνητα, σε ένα αντίστοιχο txt αρχείο με την ονομασία \textbf{results\_On2m.txt}.



\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{3.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου $O\left(n^2 m\right)$, για τις εργασίες 1-20}
    \label{fig:3}
\end{figure}



\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{4.png}
    \caption{Command Window, αλγορίθμου $O\left(n^2 m\right)$, για τις εργασίες 1-20}
    \label{fig:4}
\end{figure}


\vspace{1cm}

\subsection{Υλοποιήστε μια δική σας προσέγγιση για το πρόβλημα. Συγκρίνετε τα αποτελέσματά της με τα αποτελέσματα που παράγει ο NEH.}

Όπως αναφέρθηκε και παραπάνω, το Permutation Flow-Shop Scheduling Problem (PFSP), αφορά τον προγραμματισμό χρόνου εκτέλεσης ενός συνόλου εργασιών σε ένα σύνολο μηχανών ούτως ώστε να επιτευχθεί ο συντομότερος χρόνος ολοκλήρωσης για την εργασία που ολοκληρώνει την επεξεργασία της τελευταία. Το συγκεκριμένο πρόβλημα μπορεί να οριστεί με αλγορίθμους που σχετίζονται με την Εύρεση Βέλτιστης Λύσης. Ενδεικτικά, τέτοιοι αλγόριθμοι είναι οι:
\begin{enumerate}[label=\roman*)]
\item	Γενετικοί Αλγόριθμοι
\item	Metaheuristic
\item Tabu Search
\item	Αλγόριθμος Τυχαίας Αναζήτησης
\end{enumerate}

\vspace{1cm}

Για την εξαγωγή του συγκεκριμένου ερωτήματος υλοποιήθηκε ο κώδικας του Tabu Search (\textbf{tabu.py}). Η Αναζήτηση Tabu (TS), αφορά έναν επαναληπτικό αλγόριθμο αναζήτησης γειτονιάς, όπου αυτή η γειτονιά αλλάζει δυναμικά. Η TS ενισχύει την τοπική αναζήτηση, αποφεύγοντας έτσι σημεία στο χώρο αναζήτησης, που έχουν ήδη επισκεφθεί. Κατά αυτόν τον τρόπο, αποφεύγοντας τα ήδη επισκέψιμα σημεία, αποφεύγονται και οι βρόχοι στο χώρο αναζήτησης.

Εν κατακλείδι, το κύριο χαρακτηριστικό της Αναζήτησης Tabu (Tabu Search – TS), είναι η χρήση ρητής μνήμης, με δύο στόχους:
\begin{enumerate}[label=\roman*)]
\item Αποτροπή επανεξέτασης της αναζήτησης σε λύσεις που έχουν ήδη επισκεφθεί στο παρελθόν

\item Εξερεύνηση των μη επισκέψιμων περιοχών του χώρου των λύσεων
\end{enumerate}

\vspace{0.5cm}

Τα βήματα του εν λόγω αλγορίθμου, είναι τα εξής:
\begin{enumerate}[label=\roman*)]
\item 	\textbf{1ο Βήμα:} Επιλέγεται μία αρχική (τρέχουσα) λύση.

\item	\textbf{2ο Βήμα:} Η τρέχουσα λύση καθορίζεται από μία γειτονιά τοπικών λύσεων.

\item \textbf{3ο Βήμα:} Επιλέγεται η βέλτιστη λύση, από τις τοπικές λύσεις (νέα τρέχουσα λύση).

\item	\textbf{4ο Βήμα:} Τοποθέτηση χαρακτηριστικών βέλτιστης λύσης στον πίνακα μνήμης.

\item	\textbf{5ο Βήμα:} Επανάληψη της συγκεκριμένης διαδικασίας από τη νέα τρέχουσα λύση, έως ότου ικανοποιηθεί το κριτήριο τερματισμού της διαδικασίας. 
\end{enumerate}

\vspace{0.5cm}

Τα παραπάνω βήματα του αλγορίθμου TS (Tabu Search), έχουν υλοποιηθεί στον κώδικα \textbf{tabu.py}.

Τα δεδομένα των αρχείων βρίσκονται σε μορφή .dat, και αντλούνται online από έναν public φάκελο στο GitHub, που βρίσκεται στον κάτωθι σύνδεσμο:

\begin{center}
\textbf{\url{https://github.com/ppatsea/Algorithms}}
\end{center}

Επιπροσθέτως, κατά την εκτέλεση του κώδικα, εμφανίζονται στο Command Window \textbf{*}, τα εξής:
\begin{enumerate}[label=\roman*)]
\item 	Βέλτιστη Διάταξη Εργασιών του αλγορίθμου NEH,
\item	Βέλτιστη Σειρά Εργασιών του αλγορίθμου NEH,
\item	Χρόνος Εκτέλεσης του αλγορίθμου NEH,
\item	Συνολικός Χρόνος Εκτέλεσης του κάθε αρχείου dat. 
\end{enumerate}

Μετά το πέρας εκτέλεσης των αρχείων, εμφανίζεται το τελικό Διάγραμμα Gannt των συγκεκριμένων αρχείων, και τέλος όταν ο χρήστης κλείσει το παράθυρο του γραφήματος, στο Command Window εμφανίζεται ο Συνολικός Χρόνος Εκτέλεσης όλου του Προγράμματος.

\vspace{1cm}

\textbf{*} : Ο χρήστης από τις κατάλληλες γραμμές κώδικα επιλέγει αν επιθυμεί τα αποτελέσματα να εμφανίζονται αποκλειστικά και μόνο στην οθόνη, ή εκτός από αυτό, να εγγράφονται αυτόματα και όχι χειροκίνητα, σε ένα αντίστοιχο txt αρχείο με την ονομασία \textbf{results\_tabu\_search.txt}.





\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{5.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου Tabu Search (TS), για τις εργασίες 1-20}
    \label{fig:5}
\end{figure}



\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{6.png}
    \caption{Command Window, αλγορίθμου Tabu Search (TS), για τις εργασίες 1-20}
    \label{6:maze}
\end{figure}


\vspace{1cm}

\section{Συμπεράσματα}

\textbf{ΣΥΓΚΡΙΣΗ ΧΡΟΝΟΥ ΕΚΤΕΛΕΣΗΣ \& MAKESPAN:}

Από την εκτέλεση και τη σύγκριση των τριών αλγορίθμων, NEH, $O\left(n^2 m\right)$ και Tabu Search, αντίστοιχα, προκύπτουν:


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{7.png}
    \caption{Σύγκριση των τριών Αλγορίθμων, ως προς το χρόνο εκτέλεσης του κάθε αρχείου (και για τις 120 εργασίες)}
    \label{fig:7}
\end{figure} 



Από το παραπάνω γράφημα διαπιστώνεται, πως προκειμένου να εκτελεστεί κάθε αρχείο, του κάθε κώδικα, αντλείται κάποιος χρόνος. Το αποτέλεσμα είναι ο Αλγόριθμος NEH, να χρειάζεται πολύ περισσότερο χρόνο εκτέλεσης, συγκριτικά με αυτόν των άλλων δύο αλγορίθμων.



\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{8.png}
    \caption{Σύγκριση των τριών Αλγορίθμων, ως προς το χρόνο εκτέλεσης - makespan (και για τις 120 εργασίες)}
    \label{fig:8}
\end{figure} 

Από το παραπάνω γράφημα διαπιστώνεται, πως προκειμένου να εκτελεστεί ο κάθε κώδικας, είναι απαραίτητο κάποιο makespan. Το αποτέλεσμα είναι ο Αλγόριθμος $O\left(n^2 m\right)$, να χρησιμοποιεί πολύ μεγαλύτερο makespan σε σύγκριση με τον Tabu Search (TS), που χρησιμοποιεί το λιγότερο.

\vspace{0.5cm}

\textbf{ΔΙΑΓΡΑΜΜΑΤΑ GANNT:}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{9.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου NEH, για τις 120 εργασίες}
    \label{9:maze}
\end{figure} 



\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{10.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου $O\left(n^2 m\right)$, για τις 120 εργασίες}
    \label{10:maze}
\end{figure} 


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{11.png}
    \caption{Διάγραμμα Gannt, αλγορίθμου Tabu Search (TS), για τις 120 εργασίες}
    \label{fig:11}
\end{figure} 


\vspace{0.5cm}


Συνοψίζοντας, κατόπιν της εκτέλεσης των αλγορίθμων για το πρόβλημα του Flow-Shop Scheduling, παρατηρείται ότι ο NEH εμφανίζει το χρόνο εκτέλεσης που απαιτεί περισσότερο χρόνο συγκριτικά με τους Tabu Search και $O\left(n^2 m\right)$. Ωστόσο, όσον αφορά το συνολικό χρόνο ολοκλήρωσης (makespan), ο Tabu Search παράγει τις βέλτιστες λύσεις, ακολουθούμενος από τον NEH και, τέλος, από τον αλγόριθμο $O\left(n^2 m\right)$.

Ειδικότερα, ο NEH είναι ο πιο χρονοβόρος αλγόριθμος, αλλά οι λύσεις που παράγει δεν είναι πάντα οι βέλτιστες. Αντιθέτως, ο Tabu Search προσφέρει καλές λύσεις σε σύντομο χρονικό διάστημα, ενώ ο αλγόριθμος $O\left(n^2 m\right)$,  κινείται σε μια μεσαία γραμμή, προσφέροντας λύσεις με ευνοϊκή σχέση μεταξύ του χρόνου εκτέλεσης και της ποιότητας της λύσης.

Συμπερασματικά, οι Tabu Search και $O\left(n^2 m\right)$, προσφέρουν ισορροπημένες επιδόσεις μεταξύ του χρόνου εκτέλεσης και της ποιότητας των λύσεων, με τον πρώτο να ξεχωρίζει στην ποιότητα των makespan. Τέλος, είναι αξιοσημείωτο να αναφερθεί ότι, ανάλογα με τις ανάγκες του εκάστοτε προβλήματος, η επιλογή του αλγορίθμου μπορεί να γίνει βάσει του συνολικού στόχου, τη βέλτιστη λύση ή την επίτευξη ισορροπημένων αποτελεσμάτων δηλαδή, σε λογικό χρονικό διάστημα.


\end{document}
